"""
Tests unitaires pour le workflow PrefillFormState depuis un bien existant.

Ce test simule exactement le workflow frontend:
1. Frontend appelle GET /api/location/forms/bail/requirements/authenticated/ avec from_bien
2. Backend retourne prefill_data + bien_id + bailleur_id
3. Frontend soumet le formulaire avec bien_id/bailleur_id pour r√©utiliser les entit√©s
4. Backend v√©rifie que le bien et bailleur sont r√©utilis√©s (pas de doublon)

Usage:
    pytest tests/test_prefill_from_bien.py -v
    pytest tests/test_prefill_from_bien.py::test_prefill_from_bien_returns_correct_data -v
"""

import pytest
from rest_framework.test import APIClient
from location.factories import BienFactory
from location.models import Bien, Bailleur, Location


@pytest.fixture
def auth_client(settings, django_user_model):
    """Client API authentifi√© configur√© pour les tests."""
    settings.ALLOWED_HOSTS = ["localhost", "testserver"]
    settings.SECURE_SSL_REDIRECT = False  # Disable SSL redirect in tests
    user = django_user_model.objects.create_user(username="test", email="test@example.com", password="test")
    client = APIClient()
    client.force_authenticate(user=user)
    return client


@pytest.mark.django_db
class TestPrefillFromBien:
    """Tests pour le workflow PrefillFormState depuis bien."""

    def test_prefill_from_bien_returns_correct_data(self, auth_client):
        """Test que l'API retourne les bonnes donn√©es de prefill depuis un bien."""
        # 1. Cr√©er un bien avec un bailleur
        bien = BienFactory(
            adresse="12 Rue Eug√©nie Ebou√©, 75012 Paris, France",
            latitude=48.8566,
            longitude=2.3522,
            type_bien="appartement",
            superficie=45.5,
            meuble=False,
            bailleurs__count=1
        )
        bailleur = bien.bailleurs.first()

        # 2. Appeler l'API comme le fait le frontend
        response = auth_client.get(
            "/api/location/forms/bail/requirements/authenticated/",
            {
                "country": "france",
                "context_mode": "from_bien",
                "context_source_id": str(bien.id),
            },
            follow=True  # Suivre les redirections
        )

        # 3. V√©rifier la r√©ponse
        assert response.status_code == 200, f"Expected 200, got {response.status_code}"
        data = response.json()

        # V√©rifier la structure de la r√©ponse
        assert "prefill_data" in data, "prefill_data manquant dans la r√©ponse"
        assert "bien_id" in data, "bien_id manquant dans la r√©ponse"
        assert "bailleur_id" in data, "bailleur_id manquant dans la r√©ponse"
        assert "formData" in data, "formData manquant dans la r√©ponse"
        assert "location_id" in data["formData"], "location_id manquant dans formData"
        assert "locked_steps" in data, "locked_steps manquant dans la r√©ponse"

        # V√©rifier que les IDs sont corrects
        assert data["bien_id"] == str(bien.id), f"Expected bien_id={bien.id}, got {data['bien_id']}"
        assert data["bailleur_id"] == str(bailleur.id), f"Expected bailleur_id={bailleur.id}, got {data['bailleur_id']}"

        # V√©rifier que prefill_data contient l'adresse
        prefill = data["prefill_data"]
        assert "bien" in prefill, "bien manquant dans prefill_data"
        assert "localisation" in prefill["bien"], "localisation manquant dans prefill_data.bien"
        assert "adresse" in prefill["bien"]["localisation"], "adresse manquant dans prefill_data.bien.localisation"
        assert prefill["bien"]["localisation"]["adresse"] == bien.adresse, \
            f"Expected adresse={bien.adresse}, got {prefill['bien']['localisation']['adresse']}"

        # V√©rifier les locked_steps
        locked_steps = set(data["locked_steps"])

        # L'adresse DOIT √™tre lock√©e
        assert "bien.localisation.adresse" in locked_steps, \
            "L'adresse devrait √™tre lock√©e depuis un bien existant"

        # Le type de bien DOIT √™tre lock√©
        assert "bien.caracteristiques.type_bien" in locked_steps, \
            "Le type de bien devrait √™tre lock√© depuis un bien existant"

        # La superficie NE DOIT PAS √™tre lock√©e (unlocked_from_bien=True)
        assert "bien.caracteristiques.superficie" not in locked_steps, \
            "La superficie ne devrait PAS √™tre lock√©e (unlocked_from_bien=True)"

        # Le meubl√© NE DOIT PAS √™tre lock√© (unlocked_from_bien=True)
        assert "bien.caracteristiques.meuble" not in locked_steps, \
            "Le meubl√© ne devrait PAS √™tre lock√© (unlocked_from_bien=True)"

        print("\n‚úÖ Test passed: prefill_data structure correcte")
        print(f"   - bien_id: {data['bien_id']}")
        print(f"   - bailleur_id: {data['bailleur_id']}")
        print(f"   - adresse dans prefill: {prefill['bien']['localisation']['adresse']}")
        print(f"   - locked_steps: {len(locked_steps)} steps")
        print(f"   - adresse lock√©e: {'bien.localisation.adresse' in locked_steps}")
        print(f"   - superficie lock√©e: {'bien.caracteristiques.superficie' in locked_steps}")

    def test_bien_is_reused_not_duplicated(self, auth_client):
        """Test que le bien est r√©utilis√© et non dupliqu√© lors de la soumission."""
        # 1. Cr√©er un bien
        bien = BienFactory(
            adresse="12 Rue de la Paix, 75002 Paris",
            bailleurs__count=1
        )
        bailleur = bien.bailleurs.first()
        bien_count_before = Bien.objects.count()

        # 2. R√©cup√©rer les requirements
        response = auth_client.get(
            "/api/location/forms/bail/requirements/authenticated/",
            {
                "country": "france",
                "context_mode": "from_bien",
                "context_source_id": str(bien.id),
            },
            follow=True
        )
        data = response.json()

        # 3. Soumettre le formulaire avec bien_id
        # Note: M√™me avec bien_id, le serializer valide les champs requis
        # Mais le backend utilisera le bien_id pour r√©utiliser les donn√©es existantes
        payload = {
            "source": "bail",
            "country": "france",
            "bien_id": data["bien_id"],  # IMPORTANT: R√©utiliser le bien
            "bailleur_id": data["bailleur_id"],  # IMPORTANT: R√©utiliser le bailleur
            "location_id": data["formData"]["location_id"],

            # Bien (champs requis pour validation, mais bien_id sera utilis√©)
            "bien": {
                "localisation": {
                    "adresse": bien.adresse,  # Reprendre l'adresse du bien (locked)
                },
                "caracteristiques": {
                    "type_bien": "appartement",
                    "superficie": 50.0,  # Modifiable (unlocked_from_bien)
                    "meuble": True,  # Modifiable (unlocked_from_bien)
                },
                "regime": {"regime_juridique": "monopropriete"},
                "equipements": {
                    "loi_alur": {},
                },
                "energie": {},
                "performance_energetique": {},
            },

            # Bailleur (requis pour validation, mais bailleur_id sera utilis√©)
            "bailleur": {
                "bailleur_type": "physique",
                "personne": {
                    "firstName": "Test",
                    "lastName": "Bailleur",
                    "email": "bailleur@example.com",  # Email valide pour validation
                    "adresse": "1 Rue Test",
                }
            },

            # Locataires
            "locataires": [
                {
                    "firstName": "Marie",
                    "lastName": "Dupont",
                    "email": "marie.dupont@example.com",
                    "date_naissance": "1990-01-01",
                    "adresse": "10 Avenue Test, 75001 Paris",
                }
            ],
            "solidaires": False,

            # Modalit√©s financi√®res
            "modalites_financieres": {
                "loyer_hors_charges": 1200.0,
                "charges": 150.0,
                "type_charges": "provisionnelles",
            },

            # Dates
            "dates": {
                "date_debut": "2024-01-01",
            },
        }

        response = auth_client.post(
            "/api/location/create-or-update/",
            data=payload,
            format="json"
        )

        # Debug response
        print(f"\nüîç POST Response status: {response.status_code}")
        if response.status_code != 201:
            print(f"üîç Response content: {response.content.decode()}")
            print(f"üîç Response headers: {dict(response.headers)}")

        # 4. V√©rifier que le bien n'a PAS √©t√© dupliqu√©
        bien_count_after = Bien.objects.count()
        assert bien_count_after == bien_count_before, \
            f"Un nouveau bien a √©t√© cr√©√©! Before: {bien_count_before}, After: {bien_count_after}"

        # 5. V√©rifier que c'est le m√™me bien
        if response.status_code == 200:
            result = response.json()
            assert result["success"], f"Expected success=true, got {result}"

            location = Location.objects.get(id=result["location_id"])
            assert location.bien.id == bien.id, \
                f"Le bien n'est pas le m√™me! Expected: {bien.id}, Got: {location.bien.id}"

            print("\n‚úÖ Test passed: bien r√©utilis√© correctement")
            print(f"   - Bien original: {bien.id}")
            print(f"   - Bien dans location: {location.bien.id}")
            print(f"   - Nombre de biens: {bien_count_after}")
        else:
            print(f"\n‚ùå Submission failed with status {response.status_code}")
            print(f"Response: {response.content.decode()}")
            pytest.fail(f"Submission failed: {response.status_code}")

    def test_bailleur_is_reused_not_duplicated(self, auth_client):
        """Test que le bailleur est r√©utilis√© et non dupliqu√©."""
        # 1. Cr√©er un bien avec bailleur
        bien = BienFactory(bailleurs__count=1)
        bailleur = bien.bailleurs.first()
        bailleur_count_before = Bailleur.objects.count()

        # 2. R√©cup√©rer requirements
        response = auth_client.get(
            "/api/location/forms/bail/requirements/authenticated/",
            {
                "country": "france",
                "context_mode": "from_bien",
                "context_source_id": str(bien.id),
            },
            follow=True
        )
        data = response.json()

        # 3. Soumettre avec bailleur_id
        payload = {
            "source": "bail",
            "country": "france",
            "bien_id": data["bien_id"],
            "bailleur_id": data["bailleur_id"],  # IMPORTANT
            "location_id": data["formData"]["location_id"],
            "bien": {
                "localisation": {"adresse": bien.adresse},
                "caracteristiques": {
                    "type_bien": "appartement",
                    "superficie": 50.0,
                },
                "regime": {"regime_juridique": "monopropriete"},
                "equipements": {"loi_alur": {}},
                "energie": {},
                "performance_energetique": {},
            },
            "bailleur": {
                "bailleur_type": "physique",
                "personne": {
                    "firstName": "Test",
                    "lastName": "Bailleur",
                    "email": "bailleur@example.com",
                    "adresse": "1 Rue Test",
                }
            },
            "locataires": [{
                "firstName": "Test",
                "lastName": "User",
                "email": "test@example.com",
                "date_naissance": "1990-01-01",
                "adresse": "10 Avenue Test, 75001 Paris",
            }],
            "solidaires": False,
            "modalites_financieres": {
                "loyer_hors_charges": 1000.0,
                "charges": 100.0,
                "type_charges": "provisionnelles",
            },
            "dates": {"date_debut": "2024-01-01"},
        }

        response = auth_client.post(
            "/api/location/create-or-update/",
            data=payload,
            format="json"
        )

        # Debug response
        print(f"\nüîç POST Response status: {response.status_code}")
        if response.status_code != 201:
            print(f"üîç Response content: {response.content.decode()}")

        # 4. V√©rifier qu'aucun nouveau bailleur n'a √©t√© cr√©√©
        bailleur_count_after = Bailleur.objects.count()
        assert bailleur_count_after == bailleur_count_before, \
            f"Un nouveau bailleur a √©t√© cr√©√©! Before: {bailleur_count_before}, After: {bailleur_count_after}"

        if response.status_code == 200:
            result = response.json()
            assert result["success"], f"Expected success=true, got {result}"

            location = Location.objects.get(id=result["location_id"])

            # V√©rifier que c'est le m√™me bailleur
            assert location.bien.bailleurs.filter(id=bailleur.id).exists(), \
                "Le bailleur original n'est pas li√© au bien!"

            print("\n‚úÖ Test passed: bailleur r√©utilis√© correctement")
            print(f"   - Bailleur original: {bailleur.id}")
            print(f"   - Nombre de bailleurs: {bailleur_count_after}")
        else:
            print(f"\n‚ùå Submission failed: {response.status_code}")
            print(f"Response: {response.content.decode()}")
            pytest.fail(f"Submission failed: {response.status_code}")

    def test_locked_fields_not_in_prefill_data(self, auth_client):
        """Test que les champs lock√©s sont bien dans prefill_data mais cach√©s c√¥t√© frontend."""
        # 1. Cr√©er un bien
        bien = BienFactory(
            adresse="123 Test Street, Paris",
            type_bien="appartement",
            periode_construction="avant 1946",
        )

        # 2. R√©cup√©rer requirements
        response = auth_client.get(
            "/api/location/forms/bail/requirements/authenticated/",
            {
                "country": "france",
                "context_mode": "from_bien",
                "context_source_id": str(bien.id),
            },
            follow=True
        )
        data = response.json()
        prefill = data["prefill_data"]
        locked_steps = set(data["locked_steps"])

        # 3. V√©rifier que les champs lock√©s SONT dans prefill_data
        assert prefill["bien"]["localisation"]["adresse"] == bien.adresse, \
            "L'adresse devrait √™tre dans prefill_data"

        # 4. V√©rifier que ces champs SONT dans locked_steps
        assert "bien.localisation.adresse" in locked_steps, \
            "L'adresse devrait √™tre dans locked_steps"

        assert "bien.caracteristiques.type_bien" in locked_steps, \
            "Le type de bien devrait √™tre dans locked_steps"

        # 5. Les champs unlocked_from_bien NE DOIVENT PAS √™tre lock√©s
        assert "bien.caracteristiques.superficie" not in locked_steps, \
            "La superficie ne devrait pas √™tre lock√©e"

        print("\n‚úÖ Test passed: locked fields correct")
        print(f"   - Adresse dans prefill: ‚úì")
        print(f"   - Adresse lock√©e: ‚úì")
        print(f"   - Type bien lock√©: ‚úì")
        print(f"   - Superficie unlocked: ‚úì")


@pytest.mark.django_db
class TestDebugAdresseReset:
    """Tests pour comprendre pourquoi l'adresse est reset."""

    def test_debug_adresse_in_response(self, settings, django_user_model):
        """Debug: Afficher tout le contenu de la r√©ponse pour comprendre."""
        # 0. Configure ALLOWED_HOSTS
        settings.ALLOWED_HOSTS = ["localhost", "testserver"]
        settings.SECURE_SSL_REDIRECT = False  # Disable SSL redirect in tests

        # 1. Cr√©er un utilisateur et authentifier
        user = django_user_model.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="testpass123"
        )

        # 2. Cr√©er un bien
        bien = BienFactory(
            adresse="12 Rue Eug√©nie Ebou√©, 75012 Paris, France",
            type_bien="appartement",
        )

        # 3. Appeler l'API avec authentification
        client = APIClient()
        client.force_authenticate(user=user)
        response = client.get(
            "/api/location/forms/bail/requirements/authenticated/",
            {
                "country": "france",
                "context_mode": "from_bien",
                "context_source_id": str(bien.id),
            },
            follow=True
        )

        # Debug: afficher le statut
        print(f"\nüîç Response status: {response.status_code}")
        print(f"üîç Content-Type: {response.get('Content-Type')}")

        if response.status_code != 200:
            print(f"‚ùå Error: {response.content[:1000].decode()}")
            pytest.fail(f"API returned {response.status_code}")

        data = response.json()

        # 3. Afficher TOUT pour debug
        print("\n" + "="*80)
        print("DEBUG: R√©ponse compl√®te de l'API")
        print("="*80)

        print(f"\nüìã Structure de la r√©ponse:")
        print(f"   - Keys: {list(data.keys())}")

        print(f"\nüè† bien_id: {data.get('bien_id')}")
        print(f"üë§ bailleur_id: {data.get('bailleur_id')}")
        print(f"üìç location_id: {data.get('location_id')}")

        print(f"\nüîí locked_steps ({len(data.get('locked_steps', []))}):")
        for step in sorted(data.get("locked_steps", [])):
            print(f"   - {step}")

        print(f"\nüìù prefill_data:")
        prefill = data.get("prefill_data", {})

        if "bien" in prefill:
            print(f"   bien: {list(prefill['bien'].keys())}")

            if "localisation" in prefill["bien"]:
                print(f"   bien.localisation:")
                for key, value in prefill["bien"]["localisation"].items():
                    print(f"      - {key}: {value}")

            if "caracteristiques" in prefill["bien"]:
                print(f"   bien.caracteristiques:")
                for key, value in prefill["bien"]["caracteristiques"].items():
                    print(f"      - {key}: {value}")

        if "bailleur" in prefill:
            print(f"   bailleur: {list(prefill['bailleur'].keys())}")

        print("\n" + "="*80)

        # 4. V√©rifications critiques
        assert data.get("bien_id") == str(bien.id), "bien_id incorrect"
        assert "adresse" in prefill.get("bien", {}).get("localisation", {}), \
            "‚ùå PROBL√àME: adresse manquante dans prefill_data!"
        assert prefill["bien"]["localisation"]["adresse"] == bien.adresse, \
            "‚ùå PROBL√àME: adresse incorrecte dans prefill_data!"

        print("\n‚úÖ Adresse pr√©sente dans prefill_data")
